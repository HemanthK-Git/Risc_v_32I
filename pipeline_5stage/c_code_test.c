// Complete RISC-V RV32I Instruction Test Program
// This tests all 40 instructions implemented in your processor

// Function prototypes (forward declarations)
int test_function(int p1, int p2);
int fibonacci(int n);
int factorial(int n);
int bit_operations(int val);

int main() {
    // Initialize variables
    int a = 10;
    int b = 5;
    int c = 0;
    int arr[10];
    
    // ========== R-TYPE INSTRUCTIONS ==========
    
    // ADD - Addition
    c = a + b;  // c = 15
    
    // SUB - Subtraction  
    c = a - b;  // c = 5
    
    // AND - Bitwise AND
    c = a & b;  // c = 0
    
    // OR - Bitwise OR
    c = a | b;  // c = 15
    
    // XOR - Bitwise XOR
    c = a ^ b;  // c = 15
    
    // SLL - Shift Left Logical
    c = a << 2;  // c = 40
    
    // SRL - Shift Right Logical
    c = a >> 1;  // c = 5
    
    // SRA - Shift Right Arithmetic (signed)
    int neg = -8;
    c = neg >> 1;  // c = -4 (sign extended)
    
    // SLT - Set Less Than (signed)
    c = (a < b) ? 1 : 0;  // c = 0
    
    // SLTU - Set Less Than Unsigned
    unsigned int ua = 10;
    unsigned int ub = 5;
    c = (ua < ub) ? 1 : 0;  // c = 0
    
    
    // ========== I-TYPE ALU INSTRUCTIONS ==========
    
    // ADDI - Add Immediate
    c = a + 7;  // c = 17
    
    // ANDI - AND Immediate
    c = a & 0xF;  // c = 10
    
    // ORI - OR Immediate  
    c = a | 0x5;  // c = 15
    
    // XORI - XOR Immediate
    c = a ^ 0x3;  // c = 9
    
    // SLLI - Shift Left Logical Immediate
    c = a << 3;  // c = 80
    
    // SRLI - Shift Right Logical Immediate
    c = a >> 2;  // c = 2
    
    // SRAI - Shift Right Arithmetic Immediate
    c = neg >> 2;  // c = -2
    
    // SLTI - Set Less Than Immediate (signed)
    c = (a < 20) ? 1 : 0;  // c = 1
    
    // SLTIU - Set Less Than Immediate Unsigned
    c = (ua < 20) ? 1 : 0;  // c = 1
    
    
    // ========== LOAD INSTRUCTIONS ==========
    
    // Initialize array
    arr[0] = 0x12345678;
    arr[1] = 0xABCDEF00;
    arr[2] = -100;
    
    // LW - Load Word
    c = arr[0];  // c = 0x12345678
    
    // LH - Load Halfword (sign extended)
    short *hp = (short*)arr;
    c = hp[0];  // Load lower 16 bits, sign extended
    
    // LHU - Load Halfword Unsigned (zero extended)
    c = (unsigned short)hp[0];
    
    // LB - Load Byte (sign extended)
    char *bp = (char*)arr;
    c = bp[0];  // Load byte, sign extended
    
    // LBU - Load Byte Unsigned (zero extended)
    c = (unsigned char)bp[0];
    
    
    // ========== STORE INSTRUCTIONS ==========
    
    // SW - Store Word
    arr[3] = 0xDEADBEEF;
    
    // SH - Store Halfword
    hp[6] = 0x1234;
    
    // SB - Store Byte
    bp[14] = 0xAB;
    
    
    // ========== BRANCH INSTRUCTIONS ==========
    
    int x = 10;
    int y = 20;
    
    // BEQ - Branch if Equal
    if (x == x) {
        c = 1;
    }
    
    // BNE - Branch if Not Equal
    if (x != y) {
        c = 2;
    }
    
    // BLT - Branch if Less Than (signed)
    if (x < y) {
        c = 3;
    }
    
    // BGE - Branch if Greater or Equal (signed)
    if (y >= x) {
        c = 4;
    }
    
    // BLTU - Branch if Less Than Unsigned
    unsigned int ux = 10;
    unsigned int uy = 20;
    if (ux < uy) {
        c = 5;
    }
    
    // BGEU - Branch if Greater or Equal Unsigned
    if (uy >= ux) {
        c = 6;
    }
    
    
    // ========== JUMP INSTRUCTIONS ==========
    
    // JAL - Jump and Link (function call)
    // This will be generated by function calls
    c = test_function(5, 3);
    
    // JALR is used for function returns and indirect jumps
    // Automatically generated by compiler for return statements
    
    
    // ========== UPPER IMMEDIATE INSTRUCTIONS ==========
    
    // LUI - Load Upper Immediate
    int upper = 0x12345000;  // Compiler generates LUI
    
    // AUIPC - Add Upper Immediate to PC
    // Used for position-independent code (may be generated by compiler)
    
    
    // ========== LOOPS (tests branches extensively) ==========
    
    // For loop
    int sum = 0;
    for (int i = 0; i < 10; i++) {
        sum += i;
    }
    
    // While loop
    int count = 0;
    while (count < 5) {
        count++;
    }
    
    // Do-while loop
    int n = 0;
    do {
        n++;
    } while (n < 3);
    
    
    // ========== COMPLEX OPERATIONS ==========
    
    // Nested conditions
    if (a > 5) {
        if (b < 10) {
            c = a + b;
        } else {
            c = a - b;
        }
    }
    
    // Switch statement (generates jump tables)
    switch (a) {
        case 1:
            c = 10;
            break;
        case 2:
            c = 20;
            break;
        case 10:
            c = 100;
            break;
        default:
            c = 0;
    }
    
    // Array operations
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 2;
    }
    
    // Pointer arithmetic
    int *ptr = arr;
    *ptr = 42;
    ptr++;
    *ptr = 84;
    
    return sum;
}


// Helper function to test JAL/JALR
int test_function(int p1, int p2) {
    int result = p1 * p2;
    
    // Recursive call to generate more JAL/JALR
    if (p1 > 1) {
        result += test_function(p1 - 1, p2);
    }
    
    return result;
}


// Additional test functions
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// Bit manipulation tests
int bit_operations(int val) {
    int result = 0;
    
    // Shift operations
    result = (val << 1) | (val >> 1);
    
    // Mask operations
    result &= 0xFF;
    result |= 0x100;
    
    // XOR swap
    int temp = val;
    result ^= temp;
    temp ^= result;
    result ^= temp;
    
    return result;
}
